## 栈结构

1. 后进先出 LIFO
2. 受限的线性结构
3. 应用:
    - 函数应用栈
    - 递归
        - 如果递归太多,就会导致栈溢出
4. 栈结构面试题

![20200511234128](https://raw.githubusercontent.com/kakigakki/picBed/master/imgs/20200511234128.png)

5. _基于数组_,js 代码实现栈
    1. 常见操作
        1. push()
        2. pop()
        3. peek()
        4. isEmpty()
        5. size()
        6. toString()
6. _实战_:算法应用: 给定一个十进制的数,转成二进制

## 队列结构

1. 先进先出,FIFO
2. 受限的线性结构
3. 只允许前端删除,后端插入
4. 应用:
    1. 打印队列
    2. 线程队列
5. _实战_:基于数组实现队列
    1. 常用操作:
        1. enqueue() 往后端加一个元素
        2. dequeue() 在前端删除一个元素
        3. front() 查看前端的元素
        4. isEmpty() 查看队列是否为空
        5. size() 查看队列中元素的个数
        6. toString()
6. _实战_:算法应用:击鼓传花(每次删除圆圈中的第 n 个数,求出最后一个剩下的数的原先的位置)

## 优先级队列

1. 在普通队列的基础上加入优先级
2. 在插入新元素的时候,会考虑该数据的优先级,与其他元素比较优先级,然后再插入队列
3. 应用:多线程
4. _实战_ : js 代码基于数组实现优先级队列

## 链表

1. 链表中的元素在内存中不必是连续的空间.
2. 链表的每一个元素有一个存储元素本身的节点和一个指向下一个元素的**引用**(指针 next),通过此引用将一个个的节点连接起来

    ![20200515114746](https://raw.githubusercontent.com/kakigakki/picBed/master/imgs/20200515114746.png)

3. 优点:插入和删除数据时,时间复杂度可以达到 O(1)
4. 缺点: 访问任何一个位置的元素时,都需要从头访问
5. **实战**: 封装一个链表,实现下列操作
6. 常见操作:
    - append(element)
        - 需要判断是否添加的是第一个节点
    - insert(position,element)
        - position 的越界判断,不为负,不超过 length
        - 需要有 current 和 previous 来表示插入之前前的前后节点
    - get(position)
    - indexOf(element)
    - update(position,element)
    - removeAt(position)
    - remove(element)
    - isEmpty()
    - size()
    - toString()
        - 主要是通过 current 去移动指针

## 双向链表

1. 既可以从头遍历到尾,也可以从尾到头
2. 每个节点有两个引用`prev,next`和一个数据`data`
3. 一般有一个`head`指针和`tail`指针
4. **实战** :封装一个双向列表,并实现常见操作
5. 常见操作:
    - append(ele)
    - insert(pos,ele):需要分析插入的位置是最前,最后,还是中间.
    - get(pos) : 需要分析从头开始找还是从尾开始找
    - indexOf(ele)
    - update(pos,ele)
    - removeAt(pos)
    - remove(pos)
    - isEmpty()
    - size()
    - toString()
    - forwardString()
    - backwardString()

## 集合

1. 无序,不能重复
2. 不能通过下标进行访问,相同对象在集合中只能存在一份
3. 封装一个简单的集合类:
    - add(value)
    - remove(value)
    - has()
    - clear()
    - size()
    - value()
    - union() : 两个集合的并集
    - intersetion() : 两个集合的交集
    - difference() : 两个集合的差集
    - subSet() : A 集合是否是 B 集合的子集

## 字典

1. 字典的主要特点就是一一对应的关系
2. 键值对
3. key 不可以重复,value 可以重复
4. key 是无序的

## 哈希表

1. 将字符串用哈希函数转为为下标,可以通过字符串快速查找,底层采用数组
2. 产生冲突后,利用`链地址法`或者`开发地址法`进行冲突解决
    - 链地址法:在产生冲突的地方创建链表或者数组,放入新元素
    - 开放地址法: 在产生冲突的地方往下找空地方
        - `线性探测`
        - `二分探测`
        - `再哈希化`
3. 自己创建一个`哈希函数`:
    - 利用霍尔算法算出每个字符串的 hashcode:`hashcode = hashcode *37 + 字符编码`
4. 用`链地址法`自己封装一个`哈希表`数据结构
    - storage : 所有元素存放的数组
    - count : 已经存放的元素
    - limit : 数组的长度(一般为质数)
    - hashFunc(str,size) : 哈希函数,给字符串创建 hashcode,从而分配下标存入`storage`
    - put(key,value) :插入或者修改
    - get(key): 获取
    - remove(key) :删除
    - size()
    - isEmpty()
    - resize(newLimit) :
        - 哈希表扩容,或者减容,在 put 后可能需要扩容,在 remove 后可能需要减容
        - 一般新容量也为质数
        - 一般当 count/limit >0.75 或者<0.25 时进行扩容或者减容
5. 哈希表的扩容思想
    - 当使用`链地址法`时,loadFactor 是可以大于 1 的(即,元素个数大于哈希表的容量)
    - 但是随着数据量的增多,每一个 index 对应的 bucket 也会越来越长,就造成了效率的低下
    - 一般在扩容因子到达 0.75 的时候,就需要对哈希表进行扩容

## 树结构

1.  优点:
    -   查找速度为链表,数组快,但是没有哈希表快
    -   具有哈希表没有的:
        -   哈希表是无序的,树是有序的
        -   哈希表无法查找最大值最小值,树可以
        -   哈希表空间率低的问题(因为底层是数组,利用哈希函数时,开辟的空间往往没有全部利用)
1.  缺点:
    -   非平衡树是很容易变成链表,查找效率就从 O(logn)变成了 O(n)
1.  概念:
    -   树(tree) :由 n 个节点构成的有限集合
    -   根(root) : 每个树的根
    -   子树(subtree) : 每棵树互不相交的子树
    -   子节点(child)
    -   父节点(parent)
    -   度(degree): 节点的字数个数
    -   树的度 : 树的最大度(如:二叉树就是 2)
    -   叶节点(leaf) : 没有度的节点
    -   兄弟节点(sibling)
    -   路径:一个节点到另一个节点的路径个数
    -   路径长度: 每条路径的边(相邻节点之间的距离)有几个
    -   节点的层次(level) : 规定根节点在 1 层,其他任一节点的层数是其父节点的层数+1
    -   树的深度(depth) : 树中所有节点中的最大层次是这颗树的深度

## 二叉树

1.  衍生: 任何一颗树都可以转换为二叉树
1.  二叉树中有几个比较重要的特性
    -   二叉树第 i 层的最大节点数为 2^(i-1)
    -   深度为 k 的二叉树的最大节点总数为: 2^k-1
    -   对任何非空二叉树,若 n0 表示叶节点的个数,n2 是度为 2 的节点的个数,那么两者满足关系 n0 = n2+1
1.  二叉树形态

    -   满二叉树(完美二叉树) : 除叶子节点外,每个节点都有两个子节点

    ![20200711114056](https://raw.githubusercontent.com/kakigakki/picBed/master/imgs/20200711114056.png)

    -   完全二叉树:
        -   除了最后一层外,其他各层的节点数都达到了最大个数
        -   且最后一层的叶节点必须是从左到右连续的,只缺右侧的若干个叶
        -   完美二叉树是特殊的完全二叉树

    ![20200711114239](https://raw.githubusercontent.com/kakigakki/picBed/master/imgs/20200711114239.png)

1.  二叉树的表示方法
    -   完全二叉树可以用数组表示,且不会造成空间浪费
    -   非完全二叉树,一般使用链表进行表示

## 二叉搜索树(Binary Search Tree)

        二叉查找树又叫二叉搜索树，

        它或者是一棵空树，或者是具有下列性质的二叉树：

        若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；

        若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；

        它的左、右子树也分别为二叉搜索树。

![20200714225931](https://raw.githubusercontent.com/kakigakki/picBed/master/imgs/20200714225931.png)

1.  用链表的结构封装一个二叉搜索树
    每个节点有`left`,`right`,`key`三个属性

1.  常见操作
    -   insert(key) : 向树中插入一个新键
        -   需要判断是否有根节点
        -   使用递归
    -   has(key)
    -   update(old,new)
    -   inOrderTraversal() :中序遍历 :左子树=>根节点=>右子树 (使用递归)
    -   preOrderTraversal() : 先序遍历:根节点=>左子树=>右子树 (使用递归)
    -   postOrderTraversal() :后序遍历:左子树=>右子树=>根节点 (使用递归)
    -   min
    -   max
    -   remove(key)
        -   情况 1 :是叶子节点
        -   情况 2 :只有一个子节点
        -   情况 3:有两个子节点

## 红黑树

1. 平衡的二叉树的一种形态就是红黑树
1. 因为二叉树在不平衡的时候会变成接近于链表,所以需要将其平衡,就需要红黑树
1. 红黑树的规则:
    - 节点是`红色`或者`黑色`
    - `根节点`是黑色
    - `叶子节点`都是黑色的`空节点`(null) ,即有数据的节点,肯定不会是`叶子节点`
    - 每个红色的节点的两个子节点都是黑色(根节点到叶子节点上,不能有两个连续的红色节点)
    - 从`任一节点`到其`每个叶子`的所有路径都包含相同数目的`黑色节点`
1. 红黑树的特性:
    - 从根到叶子的`最长可能路径`,不会超过`最短可能路径`的两倍长
1. 红黑树插入时,节点变化方式
    - 变色
    - 左旋转
    - 右旋转
