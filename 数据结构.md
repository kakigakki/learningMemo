## 栈结构
1. 后进先出 LIFO 
2. 受限的线性结构
3. 应用:
    - 函数应用栈
    - 递归
        - 如果递归太多,就会导致栈溢出
4. 栈结构面试题

![20200511234128](https://raw.githubusercontent.com/kakigakki/picBed/master/imgs/20200511234128.png)
5. *基于数组*,js代码实现栈
    1. 常见操作
        1. push()
        2. pop()
        3. peek()
        4. isEmpty()
        5. size()
        6. toString()
6. *实战*:算法应用: 给定一个十进制的数,转成二进制

## 队列结构
1. 先进先出,FIFO
2. 受限的线性结构
3. 只允许前端删除,后端插入
4. 应用:
    1. 打印队列
    2. 线程队列
5. *实战*:基于数组实现队列
    1. 常用操作:
        1. enqueue() 往后端加一个元素
        2. dequeue() 在前端删除一个元素
        3. front()   查看前端的元素
        4. isEmpty() 查看队列是否为空
        5. size()    查看队列中元素的个数
        6. toString() 
7. *实战*:算法应用:击鼓传花(每次删除圆圈中的第n个数,求出最后一个剩下的数的原先的位置)

## 优先级队列
1. 在普通队列的基础上加入优先级
2. 在插入新元素的时候,会考虑该数据的优先级,与其他元素比较优先级,然后再插入队列
3. 应用:多线程
4. *实战* : js代码基于数组实现优先级队列

## 链表

1. 链表中的元素在内存中不必是连续的空间.
2. 链表的每一个元素有一个存储元素本身的节点和一个指向下一个元素的**引用**(指针next),通过此引用将一个个的节点连接起来

    ![20200515114746](https://raw.githubusercontent.com/kakigakki/picBed/master/imgs/20200515114746.png)
3. 优点:插入和删除数据时,时间复杂度可以达到O(1)
4. 缺点: 访问任何一个位置的元素时,都需要从头访问
5. **实战**: 封装一个链表,实现下列操作
6. 常见操作:
    - append(element)
        - 需要判断是否添加的是第一个节点
    - insert(position,element)
        - position的越界判断,不为负,不超过length
        - 需要有current和previous来表示插入之前前的前后节点
    - get(position)
    - indexOf(element)
    - update(position,element)
    - removeAt(position)
    - remove(element)
    - isEmpty()
    - size()
    - toString()
        - 主要是通过current去移动指针