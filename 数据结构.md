## 栈结构

1. 后进先出 LIFO
2. 受限的线性结构
3. 应用:
    - 函数应用栈
    - 递归
        - 如果递归太多,就会导致栈溢出
4. 栈结构面试题

![20200511234128](https://raw.githubusercontent.com/kakigakki/picBed/master/imgs/20200511234128.png)

5. _基于数组_,js 代码实现栈
    1. 常见操作
        1. push()
        2. pop()
        3. peek()
        4. isEmpty()
        5. size()
        6. toString()
6. _实战_:算法应用: 给定一个十进制的数,转成二进制

## 队列结构

1. 先进先出,FIFO
2. 受限的线性结构
3. 只允许前端删除,后端插入
4. 应用:
    1. 打印队列
    2. 线程队列
5. _实战_:基于数组实现队列
    1. 常用操作:
        1. enqueue() 往后端加一个元素
        2. dequeue() 在前端删除一个元素
        3. front() 查看前端的元素
        4. isEmpty() 查看队列是否为空
        5. size() 查看队列中元素的个数
        6. toString()
6. _实战_:算法应用:击鼓传花(每次删除圆圈中的第 n 个数,求出最后一个剩下的数的原先的位置)

## 优先级队列

1. 在普通队列的基础上加入优先级
2. 在插入新元素的时候,会考虑该数据的优先级,与其他元素比较优先级,然后再插入队列
3. 应用:多线程
4. _实战_ : js 代码基于数组实现优先级队列

## 链表

1. 链表中的元素在内存中不必是连续的空间.
2. 链表的每一个元素有一个存储元素本身的节点和一个指向下一个元素的**引用**(指针 next),通过此引用将一个个的节点连接起来

    ![20200515114746](https://raw.githubusercontent.com/kakigakki/picBed/master/imgs/20200515114746.png)

3. 优点:插入和删除数据时,时间复杂度可以达到 O(1)
4. 缺点: 访问任何一个位置的元素时,都需要从头访问
5. **实战**: 封装一个链表,实现下列操作
6. 常见操作:
    - append(element)
        - 需要判断是否添加的是第一个节点
    - insert(position,element)
        - position 的越界判断,不为负,不超过 length
        - 需要有 current 和 previous 来表示插入之前前的前后节点
    - get(position)
    - indexOf(element)
    - update(position,element)
    - removeAt(position)
    - remove(element)
    - isEmpty()
    - size()
    - toString()
        - 主要是通过 current 去移动指针

## 双向链表

1. 既可以从头遍历到尾,也可以从尾到头
2. 每个节点有两个引用`prev,next`和一个数据`data`
3. 一般有一个`head`指针和`tail`指针
4. **实战** :封装一个双向列表,并实现常见操作
5. 常见操作:
    - append(ele)
    - insert(pos,ele):需要分析插入的位置是最前,最后,还是中间.
    - get(pos) : 需要分析从头开始找还是从尾开始找
    - indexOf(ele)
    - update(pos,ele)
    - removeAt(pos)
    - remove(pos)
    - isEmpty()
    - size()
    - toString()
    - forwardString()
    - backwardString()

## 集合

1. 无序,不能重复
2. 不能通过下标进行访问,相同对象在集合中只能存在一份
3. 封装一个简单的集合类:
    - add(value)
    - remove(value)
    - has()
    - clear()
    - size()
    - value()
    - union() : 两个集合的并集
    - intersetion() : 两个集合的交集
    - difference() : 两个集合的差集
    - subSet() : A 集合是否是 B 集合的子集

## 字典

1. 字典的主要特点就是一一对应的关系
2. 键值对
3. key 不可以重复,value 可以重复
4. key 是无序的

## 哈希表

1. 将字符串用哈希函数转为为下标,可以通过字符串快速查找
2. 产生冲突后,利用`链地址法`或者`开发地址法`进行冲突解决
    - 链地址法:在产生冲突的地方创建链表或者数组,放入新元素
    - 开放地址法: 在产生冲突的地方往下找空地方
        - `线性探测`
        - `二分探测`
        - `再哈希化`
3. 自己创建一个`哈希函数`:
    - 利用霍尔算法算出每个字符串的 hashcode:`hashcode = hashcode *37 + 字符编码`
4. 用`链地址法`自己封装一个`哈希表`数据结构
    - storage : 所有元素存放的数组
    - count : 已经存放的元素
    - limit : 数组的长度(一般为质数)
    - hashFunc(str,size) : 哈希函数,给字符串创建 hashcode,从而分配下标存入`storage`
    - put(key,value) :插入或者修改
    - get(key): 获取
    - remove(key) :删除
    - size()
    - isEmpty()
    - resize(newLimit) :
        - 哈希表扩容,或者减容,在 put 后可能需要扩容,在 remove 后可能需要减容
        - 一般新容量也为质数
        - 一般当 count/limit >0.75 或者<0.25 时进行扩容或者减容
5. 哈希表的扩容思想
    - 当使用`链地址法`时,loadFactor 是可以大于 1 的(即,元素个数大于哈希表的容量)
    - 但是随着数据量的增多,每一个 index 对应的 bucket 也会越来越长,就造成了效率的低下
    - 一般在扩容因子到达 0.75 的时候,就需要对哈希表进行扩容
